{"ast":null,"code":"/**\n * Class that manages making request, called by all of the API methods.\n * @type {[type]}\n */\nmodule.exports = Transport;\n\nvar _ = require('lodash');\n\nvar utils = require('./utils');\n\nvar errors = require('./errors');\n\nvar Host = require('./host');\n\nvar patchSniffOnConnectionFault = require('./transport/sniff_on_connection_fault');\n\nvar findCommonProtocol = require('./transport/find_common_protocol');\n\nfunction Transport(config) {\n  var self = this;\n  config = self._config = config || {};\n  var LogClass = typeof config.log === 'function' ? config.log : require('./log');\n  config.log = self.log = new LogClass(config); // setup the connection pool\n\n  var ConnectionPool = utils.funcEnum(config, 'connectionPool', Transport.connectionPools, 'main');\n  self.connectionPool = new ConnectionPool(config); // setup the serializer\n\n  var Serializer = utils.funcEnum(config, 'serializer', Transport.serializers, 'json');\n  self.serializer = new Serializer(config); // setup the nodesToHostCallback\n\n  self.nodesToHostCallback = utils.funcEnum(config, 'nodesToHostCallback', Transport.nodesToHostCallbacks, 'main'); // setup max retries\n\n  self.maxRetries = config.hasOwnProperty('maxRetries') ? config.maxRetries : 3; // setup endpoint to use for sniffing\n\n  self.sniffEndpoint = config.hasOwnProperty('sniffEndpoint') ? config.sniffEndpoint : '/_nodes/_all/http'; // setup requestTimeout default\n\n  self.requestTimeout = config.hasOwnProperty('requestTimeout') ? config.requestTimeout : 30000;\n\n  if (config.hasOwnProperty('defer')) {\n    self.defer = config.defer;\n  } // randomizeHosts option\n\n\n  var randomizeHosts = config.hasOwnProperty('randomizeHosts') ? !!config.randomizeHosts : true;\n\n  if (config.host) {\n    config.hosts = config.host;\n  }\n\n  if (config.hosts) {\n    var hostsConfig = utils.createArray(config.hosts, function (val) {\n      if (_.isPlainObject(val) || _.isString(val) || val instanceof Host) {\n        return val;\n      }\n    });\n\n    if (!hostsConfig) {\n      throw new TypeError('Invalid hosts config. Expected a URL, an array of urls, a host config object, ' + 'or an array of host config objects.');\n    }\n\n    if (randomizeHosts) {\n      hostsConfig = _.shuffle(hostsConfig);\n    }\n\n    self.setHosts(hostsConfig);\n  }\n\n  if (config.hasOwnProperty('sniffedNodesProtocol')) {\n    self.sniffedNodesProtocol = config.sniffedNodesProtocol || null;\n  } else {\n    self.sniffedNodesProtocol = findCommonProtocol(self.connectionPool.getAllHosts()) || null;\n  }\n\n  if (config.hasOwnProperty('sniffedNodesFilterPath')) {\n    self.sniffedNodesFilterPath = config.sniffedNodesFilterPath;\n  } else {\n    self.sniffedNodesFilterPath = ['nodes.*.http.publish_address', 'nodes.*.name', 'nodes.*.hostname', 'nodes.*.host', 'nodes.*.version'].join(',');\n  }\n\n  if (config.sniffOnStart) {\n    self.sniff();\n  }\n\n  if (config.sniffInterval) {\n    self._timeout(function doSniff() {\n      self.sniff();\n\n      self._timeout(doSniff, config.sniffInterval);\n    }, config.sniffInterval);\n  }\n\n  if (config.sniffOnConnectionFault) {\n    patchSniffOnConnectionFault(self);\n  }\n}\n\nTransport.connectionPools = {\n  main: require('./connection_pool')\n};\nTransport.serializers = require('./serializers');\nTransport.nodesToHostCallbacks = {\n  main: require('./nodes_to_host')\n};\n\nTransport.prototype.defer = function () {\n  if (typeof Promise === 'undefined') {\n    throw new Error('No Promise implementation found. In order for elasticsearch-js to create promises ' + 'either specify the `defer` configuration or include a global Promise shim');\n  }\n\n  var defer = {};\n  defer.promise = new Promise(function (resolve, reject) {\n    defer.resolve = resolve;\n    defer.reject = reject;\n  });\n  return defer;\n};\n/**\n * Perform a request with the client's transport\n *\n * @method request\n * @todo async body writing\n * @todo abort\n * @todo access to custom headers, modifying of request in general\n * @param {object} params\n * @param {Number} params.requestTimeout - timeout for the entire request (inculding all retries)\n * @param {Number} params.maxRetries - number of times to re-run request if the\n *   original node chosen can not be connected to.\n * @param {string} [params.path=\"/\"] - URL pathname. Do not include query string.\n * @param {string|object} [params.query] - Query string.\n * @param {String} params.method - The HTTP method for the request\n * @param {String} params.body - The body of the HTTP request\n * @param {Function} cb - A function to call back with (error, responseBody, responseStatus)\n */\n\n\nTransport.prototype.request = function (params, cb) {\n  var self = this;\n  var remainingRetries = this.maxRetries;\n  var requestTimeout = this.requestTimeout;\n  var connection; // set in sendReqWithConnection\n\n  var aborted = false; // several connector will respond with an error when the request is aborted\n\n  var requestAborter; // an abort function, returned by connection#request()\n\n  var requestTimeoutId; // the id of the ^timeout\n\n  var ret; // the object returned to the user, might be a promise\n\n  var defer; // the defer object, will be set when we are using promises.\n\n  var body = params.body;\n  var headers = !params.headers ? {} : _.transform(params.headers, function (headers, val, name) {\n    headers[String(name).toLowerCase()] = val;\n  });\n  self.log.debug('starting request', params); // determine the response based on the presense of a callback\n\n  if (typeof cb === 'function') {\n    // handle callbacks within a domain\n    if (process.domain) {\n      cb = process.domain.bind(cb);\n    }\n\n    ret = {\n      abort: abortRequest\n    };\n  } else {\n    defer = this.defer();\n    ret = defer.promise;\n    ret.abort = abortRequest;\n  }\n\n  if (body && params.method === 'GET') {\n    utils.nextTick(respond, new TypeError('Body can not be sent with method \"GET\"'));\n    return ret;\n  } // serialize the body\n\n\n  if (body) {\n    var serializer = self.serializer;\n    var serializeFn = serializer[params.bulkBody ? 'bulkBody' : 'serialize'];\n    body = serializeFn.call(serializer, body);\n\n    if (!headers['content-type']) {\n      headers['content-type'] = serializeFn.contentType;\n    }\n  }\n\n  if (params.hasOwnProperty('maxRetries')) {\n    remainingRetries = params.maxRetries;\n  }\n\n  if (params.hasOwnProperty('requestTimeout')) {\n    requestTimeout = params.requestTimeout;\n  }\n\n  params.req = {\n    method: params.method,\n    path: params.path || '/',\n    query: params.query,\n    body: body,\n    headers: headers\n  };\n\n  function sendReqWithConnection(err, _connection) {\n    if (aborted) {\n      return;\n    }\n\n    if (err) {\n      respond(err);\n    } else if (_connection) {\n      connection = _connection;\n      requestAborter = connection.request(params.req, checkRespForFailure);\n    } else {\n      self.log.warning('No living connections');\n      respond(new errors.NoConnections());\n    }\n  }\n\n  function checkRespForFailure(err, body, status, headers) {\n    if (aborted) {\n      return;\n    }\n\n    requestAborter = void 0;\n\n    if (err instanceof errors.RequestTypeError) {\n      self.log.error('Connection refused to execute the request', err);\n      respond(err, body, status, headers);\n      return;\n    }\n\n    if (err) {\n      connection.setStatus('dead');\n      var errMsg = err.message || '';\n      errMsg = '\\n' + params.req.method + ' ' + connection.host.makeUrl(params.req) + (errMsg.length ? ' => ' : '') + errMsg;\n\n      if (remainingRetries) {\n        remainingRetries--;\n        self.log.error('Request error, retrying' + errMsg);\n        self.connectionPool.select(sendReqWithConnection);\n      } else {\n        self.log.error('Request complete with error' + errMsg);\n        respond(new errors.ConnectionFault(err));\n      }\n    } else {\n      self.log.debug('Request complete');\n      respond(void 0, body, status, headers);\n    }\n  }\n\n  function respond(err, body, status, headers) {\n    if (aborted) {\n      return;\n    }\n\n    self._timeout(requestTimeoutId);\n\n    var parsedBody;\n    var isJson = !headers || headers['content-type'] && ~headers['content-type'].indexOf('application/json');\n\n    if (!err && body) {\n      if (isJson) {\n        parsedBody = self.serializer.deserialize(body);\n\n        if (parsedBody == null) {\n          err = new errors.Serialization();\n          parsedBody = body;\n        }\n      } else {\n        parsedBody = body;\n      }\n    } // does the response represent an error?\n\n\n    if ((!err || err instanceof errors.Serialization) && (status < 200 || status >= 300) && (!params.ignore || !_.includes(params.ignore, status))) {\n      var errorMetadata = _.pick(params.req, ['path', 'query', 'body']);\n\n      errorMetadata.statusCode = status;\n      errorMetadata.response = body;\n\n      if (status === 401 && headers && headers['www-authenticate']) {\n        errorMetadata.wwwAuthenticateDirective = headers['www-authenticate'];\n      }\n\n      if (errors[status]) {\n        err = new errors[status](parsedBody && parsedBody.error, errorMetadata);\n      } else {\n        err = new errors.Generic('unknown error', errorMetadata);\n      }\n    } // can we cast notfound to false?\n\n\n    if (params.castExists) {\n      if (err && err instanceof errors.NotFound) {\n        parsedBody = false;\n        err = void 0;\n      } else {\n        parsedBody = !err;\n      }\n    } // how do we send the response?\n\n\n    if (typeof cb === 'function') {\n      if (err) {\n        cb(err, parsedBody, status);\n      } else {\n        cb(void 0, parsedBody, status);\n      }\n    } else if (err) {\n      err.body = parsedBody;\n      err.status = status;\n      defer.reject(err);\n    } else {\n      defer.resolve(parsedBody);\n    }\n  }\n\n  function abortRequest() {\n    if (aborted) {\n      return;\n    }\n\n    aborted = true;\n    remainingRetries = 0;\n\n    self._timeout(requestTimeoutId);\n\n    if (typeof requestAborter === 'function') {\n      requestAborter();\n    }\n  }\n\n  if (requestTimeout && requestTimeout !== Infinity) {\n    requestTimeoutId = this._timeout(function () {\n      respond(new errors.RequestTimeout('Request Timeout after ' + requestTimeout + 'ms'));\n      abortRequest();\n    }, requestTimeout);\n  }\n\n  if (connection) {\n    sendReqWithConnection(void 0, connection);\n  } else {\n    self.connectionPool.select(sendReqWithConnection);\n  }\n\n  return ret;\n};\n\nTransport.prototype._timeout = function (cb, delay) {\n  if (this.closed) return;\n  var id;\n  var timers = this._timers || (this._timers = []);\n\n  if ('function' !== typeof cb) {\n    id = cb;\n    cb = void 0;\n  }\n\n  if (cb) {\n    // set the timer\n    id = setTimeout(function () {\n      _.pull(timers, id);\n\n      cb();\n    }, delay);\n    timers.push(id);\n    return id;\n  }\n\n  if (id) {\n    clearTimeout(id);\n\n    var i = this._timers.indexOf(id);\n\n    if (i !== -1) {\n      this._timers.splice(i, 1);\n    }\n  }\n};\n/**\n * Ask an ES node for a list of all the nodes, add/remove nodes from the connection\n * pool as appropriate\n *\n * @param  {Function} cb - Function to call back once complete\n */\n\n\nTransport.prototype.sniff = function (cb) {\n  var self = this;\n  var nodesToHostCallback = this.nodesToHostCallback;\n  var log = this.log;\n  var sniffedNodesProtocol = this.sniffedNodesProtocol;\n  var sniffedNodesFilterPath = this.sniffedNodesFilterPath; // make cb a function if it isn't\n\n  cb = typeof cb === 'function' ? cb : _.noop;\n  this.request({\n    path: this.sniffEndpoint,\n    query: {\n      filter_path: sniffedNodesFilterPath\n    },\n    method: 'GET'\n  }, function (err, resp, status) {\n    if (!err && resp && resp.nodes) {\n      var hostsConfigs;\n\n      try {\n        hostsConfigs = nodesToHostCallback(resp.nodes);\n      } catch (e) {\n        log.error(new Error('Unable to convert node list from ' + self.sniffEndpoint + ' to hosts durring sniff. Encountered error:\\n' + (e.stack || e.message)));\n        return;\n      }\n\n      _.forEach(hostsConfigs, function (hostConfig) {\n        if (sniffedNodesProtocol) hostConfig.protocol = sniffedNodesProtocol;\n      });\n\n      self.setHosts(hostsConfigs);\n    }\n\n    cb(err, resp, status);\n  });\n};\n/**\n * Set the host list that the transport should use.\n *\n * @param {Array<HostConfig>} hostsConfigs - an array of Hosts, or configuration objects\n *                                         that will be used to create Host objects.\n */\n\n\nTransport.prototype.setHosts = function (hostsConfigs) {\n  var globalConfig = this._config;\n  this.connectionPool.setHosts(_.map(hostsConfigs, function (conf) {\n    return conf instanceof Host ? conf : new Host(conf, globalConfig);\n  }));\n};\n/**\n * Close the Transport, which closes the logs and connection pool\n * @return {[type]} [description]\n */\n\n\nTransport.prototype.close = function () {\n  this.log.close();\n  this.closed = true;\n\n  _.each(this._timers, clearTimeout);\n\n  this._timers = null;\n  this.connectionPool.close();\n};","map":{"version":3,"sources":["/Users/steinkorsveien/Development/SpringBotTest/RestTutorial/frontend/node_modules/elasticsearch/src/lib/transport.js"],"names":["module","exports","Transport","_","require","utils","errors","Host","patchSniffOnConnectionFault","findCommonProtocol","config","self","_config","LogClass","log","ConnectionPool","funcEnum","connectionPools","connectionPool","Serializer","serializers","serializer","nodesToHostCallback","nodesToHostCallbacks","maxRetries","hasOwnProperty","sniffEndpoint","requestTimeout","defer","randomizeHosts","host","hosts","hostsConfig","createArray","val","isPlainObject","isString","TypeError","shuffle","setHosts","sniffedNodesProtocol","getAllHosts","sniffedNodesFilterPath","join","sniffOnStart","sniff","sniffInterval","_timeout","doSniff","sniffOnConnectionFault","main","prototype","Promise","Error","promise","resolve","reject","request","params","cb","remainingRetries","connection","aborted","requestAborter","requestTimeoutId","ret","body","headers","transform","name","String","toLowerCase","debug","process","domain","bind","abort","abortRequest","method","nextTick","respond","serializeFn","bulkBody","call","contentType","req","path","query","sendReqWithConnection","err","_connection","checkRespForFailure","warning","NoConnections","status","RequestTypeError","error","setStatus","errMsg","message","makeUrl","length","select","ConnectionFault","parsedBody","isJson","indexOf","deserialize","Serialization","ignore","includes","errorMetadata","pick","statusCode","response","wwwAuthenticateDirective","Generic","castExists","NotFound","Infinity","RequestTimeout","delay","closed","id","timers","_timers","setTimeout","pull","push","clearTimeout","i","splice","noop","filter_path","resp","nodes","hostsConfigs","e","stack","forEach","hostConfig","protocol","globalConfig","map","conf","close","each"],"mappings":"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","sourcesContent":["/**\n * Class that manages making request, called by all of the API methods.\n * @type {[type]}\n */\nmodule.exports = Transport;\n\nvar _ = require('lodash');\nvar utils = require('./utils');\nvar errors = require('./errors');\nvar Host = require('./host');\nvar patchSniffOnConnectionFault = require('./transport/sniff_on_connection_fault');\nvar findCommonProtocol = require('./transport/find_common_protocol');\n\nfunction Transport(config) {\n  var self = this;\n  config = self._config = config || {};\n\n  var LogClass = (typeof config.log === 'function') ? config.log : require('./log');\n  config.log = self.log = new LogClass(config);\n\n  // setup the connection pool\n  var ConnectionPool = utils.funcEnum(config, 'connectionPool', Transport.connectionPools, 'main');\n  self.connectionPool = new ConnectionPool(config);\n\n  // setup the serializer\n  var Serializer = utils.funcEnum(config, 'serializer', Transport.serializers, 'json');\n  self.serializer = new Serializer(config);\n\n  // setup the nodesToHostCallback\n  self.nodesToHostCallback = utils.funcEnum(config, 'nodesToHostCallback', Transport.nodesToHostCallbacks, 'main');\n\n  // setup max retries\n  self.maxRetries = config.hasOwnProperty('maxRetries') ? config.maxRetries : 3;\n\n  // setup endpoint to use for sniffing\n  self.sniffEndpoint = config.hasOwnProperty('sniffEndpoint') ? config.sniffEndpoint : '/_nodes/_all/http';\n\n  // setup requestTimeout default\n  self.requestTimeout = config.hasOwnProperty('requestTimeout') ? config.requestTimeout : 30000;\n\n  if (config.hasOwnProperty('defer')) {\n    self.defer = config.defer;\n  }\n\n  // randomizeHosts option\n  var randomizeHosts = config.hasOwnProperty('randomizeHosts') ? !!config.randomizeHosts : true;\n\n  if (config.host) {\n    config.hosts = config.host;\n  }\n\n  if (config.hosts) {\n    var hostsConfig = utils.createArray(config.hosts, function (val) {\n      if (_.isPlainObject(val) || _.isString(val) || val instanceof Host) {\n        return val;\n      }\n    });\n\n    if (!hostsConfig) {\n      throw new TypeError('Invalid hosts config. Expected a URL, an array of urls, a host config object, ' +\n        'or an array of host config objects.');\n    }\n\n    if (randomizeHosts) {\n      hostsConfig = _.shuffle(hostsConfig);\n    }\n\n    self.setHosts(hostsConfig);\n  }\n\n  if (config.hasOwnProperty('sniffedNodesProtocol')) {\n    self.sniffedNodesProtocol = config.sniffedNodesProtocol || null;\n  } else {\n    self.sniffedNodesProtocol = findCommonProtocol(self.connectionPool.getAllHosts()) || null;\n  }\n\n  if (config.hasOwnProperty('sniffedNodesFilterPath')) {\n    self.sniffedNodesFilterPath = config.sniffedNodesFilterPath;\n  } else {\n    self.sniffedNodesFilterPath = [\n      'nodes.*.http.publish_address',\n      'nodes.*.name',\n      'nodes.*.hostname',\n      'nodes.*.host',\n      'nodes.*.version',\n    ].join(',');\n  }\n\n  if (config.sniffOnStart) {\n    self.sniff();\n  }\n\n  if (config.sniffInterval) {\n    self._timeout(function doSniff() {\n      self.sniff();\n      self._timeout(doSniff, config.sniffInterval);\n    }, config.sniffInterval);\n  }\n\n  if (config.sniffOnConnectionFault) {\n    patchSniffOnConnectionFault(self);\n  }\n}\n\nTransport.connectionPools = {\n  main: require('./connection_pool')\n};\n\nTransport.serializers = require('./serializers');\n\nTransport.nodesToHostCallbacks = {\n  main: require('./nodes_to_host')\n};\n\nTransport.prototype.defer = function () {\n  if (typeof Promise === 'undefined') {\n    throw new Error(\n      'No Promise implementation found. In order for elasticsearch-js to create promises ' +\n      'either specify the `defer` configuration or include a global Promise shim'\n    )\n  }\n\n  var defer = {};\n  defer.promise = new Promise(function (resolve, reject) {\n    defer.resolve = resolve;\n    defer.reject = reject;\n  });\n  return defer;\n};\n\n/**\n * Perform a request with the client's transport\n *\n * @method request\n * @todo async body writing\n * @todo abort\n * @todo access to custom headers, modifying of request in general\n * @param {object} params\n * @param {Number} params.requestTimeout - timeout for the entire request (inculding all retries)\n * @param {Number} params.maxRetries - number of times to re-run request if the\n *   original node chosen can not be connected to.\n * @param {string} [params.path=\"/\"] - URL pathname. Do not include query string.\n * @param {string|object} [params.query] - Query string.\n * @param {String} params.method - The HTTP method for the request\n * @param {String} params.body - The body of the HTTP request\n * @param {Function} cb - A function to call back with (error, responseBody, responseStatus)\n */\nTransport.prototype.request = function (params, cb) {\n  var self = this;\n  var remainingRetries = this.maxRetries;\n  var requestTimeout = this.requestTimeout;\n\n  var connection; // set in sendReqWithConnection\n  var aborted = false; // several connector will respond with an error when the request is aborted\n  var requestAborter; // an abort function, returned by connection#request()\n  var requestTimeoutId; // the id of the ^timeout\n  var ret; // the object returned to the user, might be a promise\n  var defer; // the defer object, will be set when we are using promises.\n\n  var body = params.body;\n  var headers = !params.headers ? {} : _.transform(params.headers, function (headers, val, name) {\n    headers[String(name).toLowerCase()] = val;\n  });\n\n  self.log.debug('starting request', params);\n\n  // determine the response based on the presense of a callback\n  if (typeof cb === 'function') {\n    // handle callbacks within a domain\n    if (process.domain) {\n      cb = process.domain.bind(cb);\n    }\n    ret = {\n      abort: abortRequest\n    };\n  } else {\n    defer = this.defer();\n    ret = defer.promise;\n    ret.abort = abortRequest;\n  }\n\n  if (body && params.method === 'GET') {\n    utils.nextTick(respond, new TypeError('Body can not be sent with method \"GET\"'));\n    return ret;\n  }\n\n  // serialize the body\n  if (body) {\n    var serializer = self.serializer;\n    var serializeFn = serializer[params.bulkBody ? 'bulkBody' : 'serialize'];\n\n    body = serializeFn.call(serializer, body);\n    if (!headers['content-type']) {\n      headers['content-type'] = serializeFn.contentType;\n    }\n  }\n\n  if (params.hasOwnProperty('maxRetries')) {\n    remainingRetries = params.maxRetries;\n  }\n\n  if (params.hasOwnProperty('requestTimeout')) {\n    requestTimeout = params.requestTimeout;\n  }\n\n  params.req = {\n    method: params.method,\n    path: params.path || '/',\n    query: params.query,\n    body: body,\n    headers: headers\n  };\n\n  function sendReqWithConnection(err, _connection) {\n    if (aborted) {\n      return;\n    }\n\n    if (err) {\n      respond(err);\n    } else if (_connection) {\n      connection = _connection;\n      requestAborter = connection.request(params.req, checkRespForFailure);\n    } else {\n      self.log.warning('No living connections');\n      respond(new errors.NoConnections());\n    }\n  }\n\n  function checkRespForFailure(err, body, status, headers) {\n    if (aborted) {\n      return;\n    }\n\n    requestAborter = void 0;\n\n    if (err instanceof errors.RequestTypeError) {\n      self.log.error('Connection refused to execute the request', err);\n      respond(err, body, status, headers);\n      return;\n    }\n\n    if (err) {\n      connection.setStatus('dead');\n\n      var errMsg = err.message || '';\n\n      errMsg =\n        '\\n' +\n        params.req.method +\n        ' ' +\n        connection.host.makeUrl(params.req) +\n        (errMsg.length ? ' => ' : '') +\n        errMsg\n      ;\n\n      if (remainingRetries) {\n        remainingRetries--;\n        self.log.error('Request error, retrying' + errMsg);\n        self.connectionPool.select(sendReqWithConnection);\n      } else {\n        self.log.error('Request complete with error' + errMsg);\n        respond(new errors.ConnectionFault(err));\n      }\n    } else {\n      self.log.debug('Request complete');\n      respond(void 0, body, status, headers);\n    }\n  }\n\n  function respond(err, body, status, headers) {\n    if (aborted) {\n      return;\n    }\n\n    self._timeout(requestTimeoutId);\n    var parsedBody;\n    var isJson = !headers || (headers['content-type'] && ~headers['content-type'].indexOf('application/json'));\n\n    if (!err && body) {\n      if (isJson) {\n        parsedBody = self.serializer.deserialize(body);\n        if (parsedBody == null) {\n          err = new errors.Serialization();\n          parsedBody = body;\n        }\n      } else {\n        parsedBody = body;\n      }\n    }\n\n    // does the response represent an error?\n    if (\n      (!err || err instanceof errors.Serialization)\n      && (status < 200 || status >= 300)\n      && (!params.ignore || !_.includes(params.ignore, status))\n    ) {\n\n      var errorMetadata = _.pick(params.req, ['path', 'query', 'body']);\n      errorMetadata.statusCode = status;\n      errorMetadata.response = body;\n\n      if (status === 401 && headers && headers['www-authenticate']) {\n        errorMetadata.wwwAuthenticateDirective = headers['www-authenticate'];\n      }\n\n      if (errors[status]) {\n        err = new errors[status](parsedBody && parsedBody.error, errorMetadata);\n      } else {\n        err = new errors.Generic('unknown error', errorMetadata);\n      }\n    }\n\n    // can we cast notfound to false?\n    if (params.castExists) {\n      if (err && err instanceof errors.NotFound) {\n        parsedBody = false;\n        err = void 0;\n      } else {\n        parsedBody = !err;\n      }\n    }\n\n    // how do we send the response?\n    if (typeof cb === 'function') {\n      if (err) {\n        cb(err, parsedBody, status);\n      } else {\n        cb(void 0, parsedBody, status);\n      }\n    } else if (err) {\n      err.body = parsedBody;\n      err.status = status;\n      defer.reject(err);\n    } else {\n      defer.resolve(parsedBody);\n    }\n  }\n\n  function abortRequest() {\n    if (aborted) {\n      return;\n    }\n\n    aborted = true;\n    remainingRetries = 0;\n    self._timeout(requestTimeoutId);\n    if (typeof requestAborter === 'function') {\n      requestAborter();\n    }\n  }\n\n  if (requestTimeout && requestTimeout !== Infinity) {\n    requestTimeoutId = this._timeout(function () {\n      respond(new errors.RequestTimeout('Request Timeout after ' + requestTimeout + 'ms'));\n      abortRequest();\n    }, requestTimeout);\n  }\n\n  if (connection) {\n    sendReqWithConnection(void 0, connection);\n  } else {\n    self.connectionPool.select(sendReqWithConnection);\n  }\n\n  return ret;\n};\n\nTransport.prototype._timeout = function (cb, delay) {\n  if (this.closed) return;\n\n  var id;\n  var timers = this._timers || (this._timers = []);\n\n  if ('function' !== typeof cb) {\n    id = cb;\n    cb = void 0;\n  }\n\n  if (cb) {\n    // set the timer\n    id = setTimeout(function () {\n      _.pull(timers, id);\n      cb();\n    }, delay);\n\n    timers.push(id);\n    return id;\n  }\n\n  if (id) {\n    clearTimeout(id);\n\n    var i = this._timers.indexOf(id);\n    if (i !== -1) {\n      this._timers.splice(i, 1);\n    }\n  }\n};\n\n/**\n * Ask an ES node for a list of all the nodes, add/remove nodes from the connection\n * pool as appropriate\n *\n * @param  {Function} cb - Function to call back once complete\n */\nTransport.prototype.sniff = function (cb) {\n  var self = this;\n  var nodesToHostCallback = this.nodesToHostCallback;\n  var log = this.log;\n  var sniffedNodesProtocol = this.sniffedNodesProtocol;\n  var sniffedNodesFilterPath = this.sniffedNodesFilterPath;\n\n  // make cb a function if it isn't\n  cb = typeof cb === 'function' ? cb : _.noop;\n\n  this.request({\n    path: this.sniffEndpoint,\n    query: { filter_path: sniffedNodesFilterPath },\n    method: 'GET'\n  }, function (err, resp, status) {\n    if (!err && resp && resp.nodes) {\n      var hostsConfigs;\n\n      try {\n        hostsConfigs = nodesToHostCallback(resp.nodes);\n      } catch (e) {\n        log.error(new Error('Unable to convert node list from ' + self.sniffEndpoint +\n          ' to hosts durring sniff. Encountered error:\\n' + (e.stack || e.message)));\n        return;\n      }\n\n      _.forEach(hostsConfigs, function (hostConfig) {\n        if (sniffedNodesProtocol) hostConfig.protocol = sniffedNodesProtocol;\n      });\n\n      self.setHosts(hostsConfigs);\n    }\n    cb(err, resp, status);\n  });\n};\n\n/**\n * Set the host list that the transport should use.\n *\n * @param {Array<HostConfig>} hostsConfigs - an array of Hosts, or configuration objects\n *                                         that will be used to create Host objects.\n */\nTransport.prototype.setHosts = function (hostsConfigs) {\n  var globalConfig = this._config;\n  this.connectionPool.setHosts(_.map(hostsConfigs, function (conf) {\n    return (conf instanceof Host) ? conf : new Host(conf, globalConfig);\n  }));\n};\n\n/**\n * Close the Transport, which closes the logs and connection pool\n * @return {[type]} [description]\n */\nTransport.prototype.close = function () {\n  this.log.close();\n  this.closed = true;\n  _.each(this._timers, clearTimeout);\n  this._timers = null;\n  this.connectionPool.close();\n};\n"]},"metadata":{},"sourceType":"script"}